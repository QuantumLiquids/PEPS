/*
* Author: Hao-Xin Wang<wanghaoxin1996@gmail.com>
* Creation Date: 2025-02-21
*
* Description: Base class for Monte-Carlo sweep update strategies.
*/

#ifndef QLPEPS_VMC_BASIC_CONFIGURATION_UPDATE_STRATEGIES_MONTE_CARLO_SWEEP_UPDATER_BASE_H
#define QLPEPS_VMC_BASIC_CONFIGURATION_UPDATE_STRATEGIES_MONTE_CARLO_SWEEP_UPDATER_BASE_H

#include "qlpeps/vmc_basic/wave_function_component.h" // TPSWaveFunctionComponent

namespace qlpeps {
/**
 * Base class for different Monte-Carlo sweep update strategies.
 * The derived class can serve as the template parameter MCSweepUpdater in VMC executor and MC measurement executor.
 */
template<typename WaveFunctionDress = qlpeps::NoDress>
class MonteCarloSweepUpdaterBase {
 public:
  /**
   * @brief Default constructor initializes the random number generator using `std::random_device`.
   * 
   * On Linux, `std::random_device` is expected to produce non-deterministic random numbers.
   * In an MPI environment, random number generated by std::random_device in different process
   * is also expected to be independent.
   */
  MonteCarloSweepUpdaterBase() : random_engine_(std::random_device{}()) {}

  /**
   * @brief Constructor with explicit seed for reproducible Monte Carlo sampling.
   * 
   * Useful for regression testing and debugging where deterministic behavior is required.
   * 
   * @param seed The seed value for the random number generator.
   */
  explicit MonteCarloSweepUpdaterBase(unsigned int seed) : random_engine_(seed) {}

  ///< The following member function should be defined in derived class to define the MC sweep strategies.
  template<typename TenElemT, typename QNT>
  void operator()(const SplitIndexTPS<TenElemT, QNT> &sitps,
                  TPSWaveFunctionComponent<TenElemT, QNT, WaveFunctionDress> &tps_component,
                  std::vector<double> &accept_rates) {}
 protected:
  std::uniform_real_distribution<double> u_double_ = std::uniform_real_distribution<double>(0, 1.0);
  std::mt19937 random_engine_;
};
// TODO: Row-based direct-sampling MC updater
// For one row of L sites in the BMPS, directly sample a full-row
// configuration from the MPS probability distribution using sequential
// conditional sampling:
//   P(s_1,...,s_L) = P(s_1) * P(s_2|s_1) * ... * P(s_L|s_1,...,s_{L-1})
// Each conditional is obtained from the reduced density matrix at site k,
// computed by contracting the BMPS from both ends up to site k.
// With U(1) symmetry, the local Hilbert space at each step is restricted
// by the remaining quantum number budget, reducing the effective choices.
// This provides exact sampling within the BMPS approximation, dramatically
// improving ergodicity compared to local single-bond Metropolis updates.

}//qlpeps

#endif //QLPEPS_VMC_BASIC_CONFIGURATION_UPDATE_STRATEGIES_MONTE_CARLO_SWEEP_UPDATER_BASE_H

